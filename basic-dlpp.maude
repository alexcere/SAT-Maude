sload logic
sload uip

mod BASIC-DLPP is 
	pr LOGIC .
	pr UNIQUE-IMPLICATION-POINT .

    var p : Qid .
	var l x y : Literal .
	var M N CTX : Context .
	var C C' C'' : Clause .
	var CS : ClauseSet .

    crl [UnitPropagate] : M || (l \/ C), CS => M l || (l \/ C), CS
	    if M |= C == false /\ definedLiteral(l, M) =/= true .

	crl [PureLiteral] : M || (l \/ C), CS => M l || (l \/ C), CS 
	    if (~(l) in CS) =/= true /\ definedLiteral(l,M) =/= true .
 
	crl [Decide] : M || (l \/ C),CS => M d(l) || (l \/ C),CS 
	    if definedLiteral(l,M) =/= true .

	crl [Fail] : M || CS,C => failState if M |= C == false
	    /\ existsDecisionLiteral(M) =/= true .

	*** In order to guarantee that we backjump to the lowest possible
	*** level, we are separating Backjump in two rules, separating
	*** the cases with just one decision clause and the rest.

	*** If we have several decision literals along the context,
	*** the lowest level we can jump to
	*** is the one in which next literal is a decision one and
	*** it is verified that the backjump clause's only free
	*** literal is the UIP.
	*** l is the negated UIP, and C' is the backjump clause.
	crl [BackjumpWithSeveralDecisions] : M d(x) N d(y) CTX || CS, C
	    => M d(x) N l || CS,C
	    if (M d(x) N d(y) CTX) |= C == false /\ existsDecisionLiteral(N) =/= true 
		/\ C'' := removeLiteralFromClause(l, C')
	    /\ M d(x) N |= C''  == false /\ M |= C'' =/= false [nonexec] .

	*** If only one decision has been taken, we just undo that decision.
	*** The backjump clause in this case is the literal decision.
	crl [BackjumpWithOneDecision] : M d(x) N || C,CS => M ~(x) || C,CS
	    if M d(x) N |= C == false
	    /\ existsDecisionLiteral(M) =/= true . 
endm

mod DLPP-WITH-LEARNING is protecting BASIC-DLPP .

    var M : Context .
    var C : Clause .
    var CS : ClauseSet .
    
    rl [Learn] : M || CS => M || CS,C [nonexec] .

    rl [Forget] : M || CS, C => M || CS [nonexec] .

endm

mod MODERN-DLPP is protecting DLPP-WITH-LEARNING .

    var M : Context .
    var CS : ClauseSet .

    rl [Restart] : M || CS => emptyCTX || CS .

endm